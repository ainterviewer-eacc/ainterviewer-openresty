---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wei_weng.
--- DateTime: 2019/9/11 11:59
---
local db_host = ""
if PRODUCT_ENV == "sandbox" then
    db_host = "127.0.0.1"
elseif PRODUCT_ENV == "pre" then
    db_host = "127.0.0.1"
elseif PRODUCT_ENV == "online" then
    db_host = "127.0.0.1"
end

--[[
    描述: db接口的基类
    期望: 有特殊需要可从基类中派生
--]]
local Object = require "libs/classic"
local DbBase = Object:extend()
local CjsonEncode = cjson_safe.encode
local CjsonDecode = cjson_safe.decode

function DbBase:new(table, query_url, update_url, db_name, ori_url)
    self.tb_name = table
    self.query_url = query_url
    self.update_url = update_url
    self.db_name = db_name
    self.ori_url = ori_url
end

function DbBase:get_array(ttype, value)
    if "string" ~= ttype and "number" ~= ttype and "table" ~= ttype then
        ttype = "string"
    end
    local item = {}
    item["type"] = ttype
    item["value"] = value
    return item
end

--[[
    func:执行sql语句
    params:
        db_type：操作数据库类型， "read"  --读数据库，不需要加锁  "write" --写数据库，需要加锁
        sql:预编译的sql语句
        lock_key:加锁的key
        args:参数
        failed2noexit:执行错误是否退出
        unique_id:唯一id，用来确认该次请求
        split_field：分库依据字段，没有可以不传
        user_id:用户user_id
]]
function DbBase:exec(db_type, sql, lock_key, args, failed2noexit, unique_id, split_field, user_id)
    local msg = {}
    msg.sql = sql
    --nlog.info("sql" .. sql .."|" .. (split_field or ""))
    msg.values = args
    msg.lock_key = lock_key
    msg.split_field = split_field  --用户分库的字段
    msg.db_name = self.db_name
    msg.user_id = user_id
    msg.para_lock = lock_key
    local sql_url = self.query_url
	if "read" == db_type then
		msg.nolock = true
	else
		msg.nolock = false
		sql_url = self.update_url
	end
    local res = ngx.location.capture(sql_url,
    {
        args = {
            ts_table = self.tb_name,
            unique_id = unique_id
        },
        method = ngx.HTTP_POST,
        body = cjson.encode(msg)
    })

    if nil == failed2noexit then
        if ngx.HTTP_OK ~= res.status then
            nlog.error("1 query database sql: " .. sql .. ", args：" .. cjson.encode(args) ..
                ", res:" .. tostring(cjson.encode(res)))
            syncutil.exit(nil, 406, "500", "Server Internal Error.")
        end
        -- 返回一个lua表
        return cjson_safe.decode(res.body)
    else
        if ngx.HTTP_OK ~= res.status then
            nlog.error("2 query  database sql: " .. sql .. ", args:" .. cjson.encode(args) ..
                ", res:" .. tostring(cjson.encode(res)))
        end
        return res.status, cjson_safe.decode(res.body)
    end
end

--批量插入，一次更新多条sql语句
--is_multi代表是不是多条sql语句更新
function DbBase:exec_v2(is_multi, db_type, sql, lock_key, args, failed2noexit, unique_id, split_field, user_id)
    local msg = {}
    msg.sql = sql
    msg.values = args
    msg.lock_key = lock_key
    msg.split_field = split_field  --用户分库的字段
    msg.db_name = self.db_name
    msg.user_id = user_id
    msg.is_multi = is_multi
    msg.para_lock = lock_key
    local sql_url = self.query_url
	if "read" == db_type then
		msg.nolock = true
	else
		msg.nolock = false
		sql_url = self.update_url
	end
    local res = ngx.location.capture(sql_url,
    {
        args = {
            ts_table = self.tb_name,
            unique_id = unique_id
        },
        method = ngx.HTTP_POST,
        body = cjson.encode(msg)
    })

    if nil == failed2noexit then
        if ngx.HTTP_OK ~= res.status then
            nlog.error("1 query database sql: " .. cjson.encode(sql) .. "|" .. cjson.encode(args))
            syncutil.exit(nil, 406, "500", "Server Internal Error.")
        end
        -- 返回一个lua表
        return cjson_safe.decode(res.body)
    else
        if ngx.HTTP_OK ~= res.status then
            nlog.error("2 query  database sql: " .. cjson.encode(sql) .. " args:" .. cjson.encode(args))
        end
        return res.status, cjson_safe.decode(res.body)
    end
end

--[[
    func:执行sql语句，支持在nginx不同阶段使用
    params:
        db_type：操作数据库类型， "read"  --读数据库，不需要加锁  "write" --写数据库，需要加锁
        sql:预编译的sql语句
        lock_key:加锁的key
        args:参数
        failed2noexit:执行错误是否退出
        unique_id:唯一id，用来确认该次请求
        split_field：分库依据字段，没有可以不传
        user_id:用户user_id
]]
function DbBase:exec_v3(db_type, sql, lock_key, args, failed2noexit, unique_id, split_field, user_id)
    local msg = {}
    msg.sql = sql
    --nlog.info("sql" .. sql .."|" .. (split_field or ""))
    msg.values = args
    msg.lock_key = lock_key
    msg.split_field = split_field  --用户分库的字段
    msg.db_name = self.db_name
    msg.user_id = user_id
    msg.para_lock = lock_key
    local sql_url = self.query_url
    local ori_url = self.ori_url
    if "read" == db_type then
        msg.nolock = true
    else
        msg.nolock = false
        sql_url = self.update_url
    end

    local resp
    if ngx.get_phase() == "init" then
        local uri = string.format("http://%s%s", db_host, ori_url)
        local body = cjson_safe.encode(msg)
        local headers = {
            ["Content-Length"] = #body,
            ["Content-Type"] = "application/json"
        }
        resp = request_util.socket_http(uri, "POST", headers, body)
    else
        resp = ngx.location.capture(sql_url,
                {
                    args = {
                        ts_table = self.tb_name,
                        unique_id = unique_id
                    },
                    method = ngx.HTTP_POST,
                    body = cjson.encode(msg)
                })
    end

    if nil == failed2noexit then
        if not resp then
            syncutil.exit(nil, 406, "500", "Server Internal Error.")
        end
        if ngx.HTTP_OK ~= resp.status then
            --nlog.error("1 query database sql: " .. sql .. ", args：" .. cjson.encode(args) ..
            --        ", res:" .. tostring(cjson.encode(resp)))
            syncutil.exit(nil, 406, "500", "Server Internal Error.")
        end
        -- 返回一个lua表
        return cjson_safe.decode(resp.body)
    else
        if not resp then
            return nil, nil
        end
        if ngx.HTTP_OK ~= resp.status then
            --nlog.error("2 query  database sql: " .. sql .. ", args:" .. cjson.encode(args) ..
            --        ", res:" .. tostring(cjson.encode(resp)))
        end
        return resp.status, cjson_safe.decode(resp.body)
    end
end

return DbBase
